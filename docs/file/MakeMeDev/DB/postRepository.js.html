<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">MakeMeDev/DB/postRepository.js | makemedev</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="projet web 2020"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="makemedev"><meta property="twitter:description" content="projet web 2020"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/Gwenael95/MakeMeDev"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  </ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">MakeMeDev/DB/postRepository.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">const mongoose = require(&apos;mongoose&apos;);
const {postSchema} = require(&quot;../Models/postModel&quot;);
const PostModel = mongoose.model(&apos;posts&apos;, postSchema)
const {countOccurrencesFromArray} = require(&quot;../Tools/Common/countOccurence&quot;)
const {filterDelSpaces} = require(&quot;../Tools/Common/stringOperation&quot;)
const ObjectId = mongoose.Types.ObjectId;

/** @function
 * @name addPost
 * Insert a new post in database, and return the result of this try
 * --Should update Current user information, push a new post--
 * @param {object} postData - post to add, should correspond to postModels {@link &apos;../Models/postModels&apos;}.
 * @returns {Promise&lt;{success: {success: T}}|{error: Error.ValidationError | {[p: string]: ValidatorError | CastError} | number}&gt;}
 */
async function addPost(postData, user) {
    const doc = new PostModel(postData);
    return await doc.save().then(result =&gt; {
        return {success: result}
    }).catch(err =&gt; {
        return {error: err.errors}
    })
}


/** @function
 * @name getPost
 * Get post in database depending on a many fields, and return the result of this try
 * @param {object} searchedData - data to search in database
 * @returns {Promise&lt;{success: {success: T}}|{error: Error.ValidationError | {[p: string]: ValidatorError | CastError} | number}&gt;}
 */
async function getPost(searchedData) {
    return await PostModel
        .aggregate(getPipeline(searchedData))//.sort({&quot;post.totalLike&quot;:1})
        .exec()
        .then(result =&gt; {return {success: result}})
        .catch(err =&gt; {
            return {error: err.errors}
        });
}


function getCommentaryId(result, id) {
    try {
        let commentaryId;
        for (let el of result.post) {
            if (JSON.stringify(el._id) === JSON.stringify(id)) {
                commentaryId = el.commentary[el.commentary.length - 1]._id
                break
            }
        }
        return commentaryId;
    }catch (e) {
        return null
    }
}

function getResponseId(result) {
    return result.post[result.post.length - 1]._id;
}

async function updatePost(filter, update, id) {
    return await PostModel
        .findOneAndUpdate(
            filter,
            update,
            {new: true, context: &quot;query&quot;})
        //for options=&gt; upsert: true, setDefaultsOnInsert: true
        // (use on $setOnInsert; for us create issue) to update date on insert
        .lean()
        .exec()
        .then((result ) =&gt; {
            return {success: result, postId: id , responseId: getResponseId(result), commentaryId: getCommentaryId(result, id)}
        })
        .catch(err =&gt; {
            return {error: err.errors}
        });
}

async function updatePostFunction(functionPost, idPost) {
    return await updatePost({&quot;post._id&quot;: ObjectId(idPost)}, {$set : {&quot;post.$.function&quot;: functionPost}}, idPost)
}

async function updatePostResponse(responsePost, idPost) {
    return await updatePost({&quot;_id&quot;: ObjectId(idPost)}, {$push : {post: responsePost}}, idPost)
}

async function updatePostResponseCommentary(commentaryResponse, idPost) {
    return await updatePost({&quot;post._id&quot;: ObjectId(idPost)}, {$push : {&quot;post.$.commentary&quot;: commentaryResponse}}, idPost)
}

async function updateLikeOrDislike(likeOrDislike, idPost, user) {
    let opposite = {like:&quot;dislike&quot;, dislike:&quot;like&quot;}[likeOrDislike]
    //check if user already vote for this post;
    // if no : increment like or dislike field
    // if yes : if it have added a like, and now send a like : DO NOTHING  (same for dislike)
    //          if it have added a like and change is mind : $inc : -1 for like and $inc +1 for dislike (&amp; vice versa)
    //update user activities
    let setPost

    if (!(user.activities[likeOrDislike].includes(idPost) || user.activities[opposite].includes( idPost))) {
        setPost = {$inc: {[&quot;post.$.&quot; + likeOrDislike]:1}}
    }
    else if(user.activities[opposite].includes( idPost)) {
        setPost = {$inc: {[&quot;post.$.&quot; + likeOrDislike]:1, [&quot;post.$.&quot; + opposite]:-1}}
    }
    else{
        return {error:&quot;cet utilisateur &#xE0; d&#xE9;j&#xE0; mis un &quot; + likeOrDislike}
    }
    //need to update user ACTIVITIES
    return await updatePost({&quot;post._id&quot;: ObjectId(idPost)}, setPost, idPost)
}

//region not exported function
/** @function
 * @name getPipeline
 * Get a complex Pipeline to search all function depending on data search field
 * @param {object} data - post&apos;s data
 * @returns {[]}
 */
function getPipeline(data) {
    return getNameQuery(data)
        .concat(getParamTypeQuery(data), getReturnTypeQuery(data), getDescriptionQuery(data), getTagQuery(data));
}

//region query for string&apos;s array
/** @function
 * @name getTagQuery
 * Get a query to search function&apos;s tag in DB
 * @param {object} data - post&apos;s data
 * @returns {*[]|{$match: {field: {$all: data}}}[]}
 */
function getTagQuery(data) {
    return getMatchFromStringArray(data.tag, &quot;tag&quot;)
}

/** @function
 * @name getMatchFromStringArray
 * Create a $match for a defined field from database containing an array
 * Check if another array contains some or all elements of this DB field
 * @param {string} data - an array containing strings
 * @param {string} dbField - field name from DB
 * @returns {[]|[{$match: {field:{$all:data}}}]}
 */
function getMatchFromStringArray(data, dbField) {
    if (data !== null) {
        let array = (filterDelSpaces(data).split(&quot;,&quot;))
        if (array.length &gt; 0 &amp;&amp; data!==&quot;&quot;) {
            return [{$match: {[dbField]: {$all: array}}}]
        }
        else if (data===&quot;&quot;) {
            return [{$match: {[dbField]:{$size: 0}}}]
        }
    }
    return []
}
//endregion

function getTabParamOrReturn(data, types, paramsOrResults) {
    let paramOrResultTypeQuery = []
    if (data[types] !== null) {
        let dataSearch = (filterDelSpaces(data[types]).split(&quot;,&quot;))
        let occurrences = countOccurrencesFromArray(dataSearch)
        if (dataSearch.length &gt; 0) {
            return dataSearch.map(result =&gt; {
                //search the number of ? indicated in request
                if (result === &quot;?&quot;) {
                    return {
                        $match: {
                            [paramsOrResults]: {$elemMatch: {type: {$regex: &quot;&quot;}}, $size: dataSearch.length}
                        }
                    }
                } else if (dataSearch.length === 1 &amp;&amp; result === &quot;&quot;) {
                    return {$match: {[paramsOrResults]: {$size: 0}}}
                } //else search all param by params type and numbers of these types
                else if (dataSearch.length &gt;= 1) {
                    return {
                        $match: {
                            [paramsOrResults]: {$elemMatch: {type: result}, $size: dataSearch.length},
                            [types + &quot;.&quot; + result]: {
                                $lte: (occurrences[&quot;?&quot;] ? occurrences[&quot;?&quot;] : 0) + occurrences[result],
                                $gte: occurrences[result]
                            }
                        }
                    }
                }
                // else, there isn&apos;t any params in request, we search by other criteria
                else {
                    return {$match: {[paramsOrResults]: {$elemMatch: {type: {$regex: &quot;&quot;}}}}}
                }
            })
        } else if (dataSearch.length === 0) {
            return [{$match: {[paramsOrResults]: {$size: dataSearch.length}}}]
        }
    }
    return paramOrResultTypeQuery;
}

//region query for params
/** @function
 * @name getParamTypeQuery
 * Get a query to search function param&apos;s type in DB
 * $match work to search the appropriate number of params to search and types
 * @param {object} data - post&apos;s data
 * @returns {{$match: {params: {$size: number}}}[]|unknown[]|[]}
 */
function getParamTypeQuery(data) {
    return getTabParamOrReturn(data, &quot;paramsTypes&quot;, &quot;params&quot;);
}

/** @function
 * @name getReturnTypeQuery
 * Get a query to search function return&apos;s type in DB
 * @param {object} data - post&apos;s data
 * @returns {*[]|{$match: {field: {$regex: data}}}[]}
 */
function getReturnTypeQuery(data) {
    return getTabParamOrReturn(data, &quot;returnsTypes&quot;, &quot;returns&quot;);
}
//endregion

//region query for string
/** @function
 * @name getDescriptionQuery
 * Get a query to search function&apos;s description in DB
 * @param {object} data - post&apos;s data
 * @returns {*[]|{$match: {field: {$regex: data}}}[]}
 */
function getDescriptionQuery(data) {
    return getMatchStringRegex (data.description, &quot;post.description&quot;)
}

/** @function
 * @name getNameQuery
 * Get a query to search function&apos;s name in DB
 * @param {object} data - post&apos;s data
 * @returns {*[]|{$match: {field: {$regex: data}}}[]}
 */
function getNameQuery(data) {
    return getMatchStringRegex (data.functionName, &quot;name&quot;)
}

/** @function
 * @name getMatchStringRegex
 * Return an array with a $match for a defined DB field
 * @param {string} data - a string that will be used in regex
 * @param {string} dbField -
 * @returns {*[]|{$match: {field: {$regex:data}}}[]}
 */
function getMatchStringRegex(data, dbField){
    if (data !== null) {
        return [{$match: {[dbField]: {$regex: data}}}];
    }
    return []
}
//endregion

//endregion


module.exports = {addPost, getPost, updateLikeOrDislike, updatePostResponse, updatePostResponseCommentary, updatePostFunction};
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
