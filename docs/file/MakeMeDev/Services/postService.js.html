<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">MakeMeDev/Services/postService.js | makemedev</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="projet web 2020"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="makemedev"><meta property="twitter:description" content="projet web 2020"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/Gwenael95/MakeMeDev"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  </ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">MakeMeDev/Services/postService.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">const {getHandler, getHandlerForUserPost} = require(&quot;../Tools/Services/responseHandler&quot;);
const {addPost, getPost, updateLikeOrDislike, updatePostResponse, updatePostResponseCommentary, updatePostFunction} = require(&quot;../DB/postRepository&quot;)
const {countOccurrencesFromArray} = require(&quot;../Tools/Common/countOccurence&quot;)
const {updateUserById} = require(&quot;../DB/userRepository&quot;);
const {generateAccessToken} = require(&quot;../Tools/token&quot;)
const {isDefinedAndNotNull, isUndefinedOrNull} = require(&quot;../Tools/Common/undefinedControl&quot;)

let test = &quot;&quot;

//region exported methods

/** @function
 * @name get
 * Get posts depending on a request get thanks to a string with strict typography to demarcate
 * each field we have to check, and if not exist it will not be searched at all
 * Structure : [functionName](param1, param2, ?){returnedVar}&quot;functionDescription&quot;#tag1, tag2, tag3#
 * @param {string} post - post&apos;s field to find in database
 * @returns {Promise&lt;{code: number, body: {error: *}}|{code: number, body: *}|{code: number, body: *}|{code: number, body: {error: string}}&gt;}
 */
async function get(post) {
    const objectSearchPost = getSearchPost(post)
    return getHandler(sortAllPostByLike(await getPost(objectSearchPost)), &quot;ce post n&apos;existe pas&quot;);
}

async function updateFunction(functionPost, idPost, user) {
    if (functionPost) {
        return getHandler(await updatePostFunction(functionPost, idPost), &quot;mise &#xE0; jour de la fonction r&#xE9;ussie&quot;)
    }
    return getHandler({error: &quot;update response failed&quot;}, &quot;mise &#xE0; jou du post impossible&quot;);
}


/** @function
 * @name create
 * Create a new post, that will be add in database.
 * We had one more field : paramsTypes to have an object with a number of occurrence of each params
 * It will make it simpler to search if a post contains an amount of params
 * @param {object} post - post to add, should be really similar to postModels {@link &apos;../Models/postModels&apos;}.
 * @param {object} user - user to update, should be really similar to userModels {@link &apos;../Models/userModels&apos;}.
 * @returns {Promise&lt;{code: number, body: {error: {}}}|{code: number, body: *}|{code: number, body: {error: string}}&gt;}
 */
async function create(post, user) {
    setTypes(post, &quot;params&quot;);
    setTypes(post, &quot;returns&quot;);
    addAuthor(user ,post)
    addAuthor(user ,post.post[0])
    const result = await addPost(post, user);
    if (result.success) {
        const userRes = await updateUserById({id: user._id}, {$push: {post: result.success._id}});
        return closeUserUpdateAction(userRes, result, &quot;post cr&#xE9;&#xE9;, mais mise &#xE0; jour des donn&#xE9;es utilisateur impossible&quot;)
    }
    return getHandler(result);
}

/*
async function updateUserIfSuccess(isSuccess, function) {
    if (isSuccess){
        const userRes = await function
        generateAccessToken(userRes)
        return getHandlerForUserPost(userRes,result, &quot;mise &#xE0; jour des votes utilisateur impossible&quot;);
    }
}*/



async function updateVote(vote, idPost, user) {
    const likeOrDislike = vote === 1 ? &quot;like&quot; : &quot;dislike&quot;
    const opposite = vote === 1 ? &quot;dislike&quot; : &quot;like&quot;
    let result = await updateLikeOrDislike(likeOrDislike, idPost, user)
    //check if updated , then update user
    if (isDefinedAndNotNull(result.success)) {
        const userRes = await updateUserById({id: user._id}, {
            $push: {[&quot;activities.&quot; + likeOrDislike]: result.postId},
            $pull: {[&quot;activities.&quot; + opposite]: result.postId}
        })
        return closeUserUpdateAction(userRes, result, &quot;ajout du &quot; + likeOrDislike + &quot; sur le post &quot; + idPost + &quot; impossible&quot;)
    }
    return getHandler({error: &quot;update vote failed&quot;}, &quot;mise &#xE0; jour des votes du post impossible&quot;);
}

async function addPostResponse(responsePost, idPost, user) {
    addAuthor(user, responsePost)
    addDate(responsePost, &quot;creationDate&quot;)
    if (responsePost[&apos;function&apos;] &amp;&amp; responsePost[&apos;description&apos;]) {
        const result = await updatePostResponse(responsePost, idPost, user)
        if (result.success !== null &amp;&amp; result.success !== undefined) {
            const userRes = await updateUserById({id: user._id}, {$push: {[&quot;activities.response&quot;]: result.responseId}})
            return closeUserUpdateAction(userRes, result, &quot;ajout d&apos;une nouvelle reponse , mais mis &#xE0; jour de l&apos;utilisateur impossible&quot;)
        }
    }
    return getHandler({error: &quot;update response failed&quot;}, &quot;ajout de reponse au post impossible&quot;);
}

async function addCommentary(commentaryPost, idPost, user) {
    addAuthor(user, commentaryPost)
    addDate(commentaryPost, &quot;date&quot;)
    if (commentaryPost[&apos;commentary&apos;]) {
        const result = await updatePostResponseCommentary(commentaryPost, idPost, user)
        if (result.success !== null &amp;&amp; result.success !== undefined) {
            const userRes = await updateUserById({id: user._id}, {$push: {[&quot;activities.commentary&quot;]: result.commentaryId}})
            return closeUserUpdateAction(userRes, result, &quot;ajout du commentaires, mais mis &#xE0; jour de l&apos;utilisateur impossible&quot;)
        }
    }
    return getHandler({error: &quot;update response failed&quot;}, &quot;ajout du commentaires impossible&quot;);
}

//endregion


//region not exported functions
function closeUserUpdateAction(userData, postData, msg=&quot;erreur en base de donn&#xE9;es&quot;){
    generateAccessToken(userData)
    return getHandlerForUserPost(userData, postData, &quot;ajout du commentaires impossible&quot;);
}


function addAuthor(author, object){
    object.author =  {
        &quot;userId&quot;: author._id,
        &quot;pseudo&quot;: author.pseudo,
        &quot;avatar&quot;: author.avatar
    }
}

function addDate(object, fieldName=&quot;creationDate&quot;){
    object[fieldName] = new Date().getTime() / 1000
}


function setTypes(post, paramsOrResults) {
    if (isUndefinedOrNull(post[paramsOrResults])) {
        post[paramsOrResults] = []
    }
    let arr = []
    for (let element of post[paramsOrResults]) {
        arr.push(element.type)
    }
    post[paramsOrResults + &quot;Types&quot;] = countOccurrencesFromArray(arr)
}

function getSearchPost(post) {
    test = post
    return {
        functionName: getStringDelimitedArea(&quot;[&quot;, &quot;]&quot;),
        paramsTypes: getStringDelimitedArea(&quot;(&quot;, &quot;)&quot;),
        returnsTypes: getStringDelimitedArea(&quot;{&quot;, &quot;}&quot;),
        description: getSearchValue(&apos;&quot;&apos;),
        tag: getSearchValue(&apos;#&apos;)
    };
}

/** @function
 * @name getStringDelimitedArea
 * Get a string in a delimited area defined by first and last delimiter
 * If the second delimiter isn&apos;t found in string, return a string from first delimiter to end
 * @param {string} test - string to analyse
 * @param {string} firstDelimiter - first delimiter used  to get the result
 * @param {string} lastDelimiter - last delimiter used to get the result
 * @returns {string|null}
 */
function getStringDelimitedArea(firstDelimiter, lastDelimiter) {
    if (test.includes(firstDelimiter) &amp;&amp; test.includes(lastDelimiter)) {
        let str = test.substring(test.lastIndexOf(firstDelimiter) + 1, test.lastIndexOf(lastDelimiter))
        test = test.substring(test.lastIndexOf(lastDelimiter) + 1, test.length)
        return str
    } else {
        return null;
    }
}

/** @function
 * @name getSearchValue
 * Get a string in a delimited area defined by a delimiter
 * If there is only one delimiter, return null
 * @param {string} test - string to analyse
 * @param {string} delimiter - delimiter used to get the result
 * @returns {string|null}
 */
function getSearchValue(delimiter) {
    let value = []
    let countCharacter = 0;
    test.split(&quot;&quot;).map((searchCharacter, index) =&gt; {
        if (searchCharacter === delimiter) {
            countCharacter++
            value.push(index)
        }
    })

    if (countCharacter &gt;= 2) {
        let str = test.substring(value[0] + 1, value[1])
        test = test.substring(value[1] + 1, test.length)
        return str
    } else {
        return null;
    }
}

function sortAllPostByLike(data) {
    if (isDefinedAndNotNull(data.success)) {
        for (let func of data.success) {
            func = sortPostByLikes(func)
        }
    }
    return data
}

function sortPostByLikes(data) {
    data.post.sort(function (a, b) {
        return (b.like - b.dislike) - (a.like - a.dislike);
    })
    return data
}

//endregion

module.exports = {create, get, updateVote, addPostResponse, addCommentary, updateFunction};
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
